<!DOCTYPE html>
<html>
<head>
  <title>Draw Something</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 0; padding-top: 60px; }
    canvas { border: 2px solid black; touch-action: none; }
    #controls { margin-top: 10px; }
    #room-info {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: #000;
      color: #fff;
      padding: 10px;
      z-index: 1000;
      text-align: center;
    }
  </style>
</head>
<body>

  <div id="room-info">
    Room: {{ room_name }} | Code: <span id="room-code">{{ room_code }}</span>
  </div>

  <!-- Hidden room code for JavaScript -->
  <div id="room-data" data-room-code="{{ room_code }}"></div>

  <h1>Draw Something!</h1>
  <canvas id="canvas" width="500" height="400"></canvas>

  <div id="controls">
    <label>Color: <input type="color" id="colorPicker" value="#000000"></label>
    <label>Thickness: <input type="range" id="thickness" min="1" max="20" value="3"></label>
    <button onclick="undo()">Undo</button>
    <button onclick="clearCanvas()">Clear</button>
    <button onclick="sendDrawing()">Send</button>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const colorPicker = document.getElementById("colorPicker");
    const thicknessSlider = document.getElementById("thickness");
    const roomCode = document.getElementById("room-data").dataset.roomCode;

    let drawing = false;
    let paths = [];
    let currentPath = [];

    function getPointerPos(e) {
      const rect = canvas.getBoundingClientRect();
      if (e.touches) {
        return {
          x: e.touches[0].clientX - rect.left,
          y: e.touches[0].clientY - rect.top
        };
      }
      return { x: e.offsetX, y: e.offsetY };
    }

    function startDrawing(e) {
      drawing = true;
      currentPath = [];
      const pos = getPointerPos(e);
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
      currentPath.push({ x: pos.x, y: pos.y, color: colorPicker.value, width: thicknessSlider.value });
      e.preventDefault();
    }

    function draw(e) {
      if (!drawing) return;
      const pos = getPointerPos(e);
      ctx.strokeStyle = colorPicker.value;
      ctx.lineWidth = thicknessSlider.value;
      ctx.lineCap = "round";
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
      currentPath.push({ x: pos.x, y: pos.y, color: colorPicker.value, width: thicknessSlider.value });
      e.preventDefault();
    }

    function stopDrawing() {
      if (drawing) {
        drawing = false;
        paths.push([...currentPath]);
        ctx.beginPath();
      }
    }

    function undo() {
      if (paths.length === 0) return;
      paths.pop();
      redraw();
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      paths = [];
    }

    function redraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      for (const path of paths) {
        if (path.length === 0) continue;
        ctx.strokeStyle = path[0].color;
        ctx.lineWidth = path[0].width;
        ctx.moveTo(path[0].x, path[0].y);
        for (let i = 1; i < path.length; i++) {
          const pt = path[i];
          ctx.lineTo(pt.x, pt.y);
        }
        ctx.stroke();
        ctx.beginPath();
      }
    }

    function sendDrawing() {
      canvas.toBlob(function(blob) {
        const formData = new FormData();
        formData.append("image", blob, "drawing.png");
        formData.append("room_code", roomCode);

        fetch("/upload", {
          method: "POST",
          body: formData
        }).then(res => {
          if (res.ok) alert("Drawing sent!");
          else alert("Upload error");
        }).catch(err => {
          console.error(err);
          alert("Upload failed");
        });
      }, "image/png");
    }

    canvas.addEventListener("mousedown", startDrawing);
    canvas.addEventListener("mousemove", draw);
    canvas.addEventListener("mouseup", stopDrawing);
    canvas.addEventListener("mouseleave", stopDrawing);

    canvas.addEventListener("touchstart", startDrawing, { passive: false });
    canvas.addEventListener("touchmove", draw, { passive: false });
    canvas.addEventListener("touchend", stopDrawing);
  </script>
</body>
</html>
